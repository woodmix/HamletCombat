/**
 * 実行素子が位置する矩形に関するビヘイバ(ボディビヘイバー)を納めたファイル。
 * ボディビヘイバー単体ではあまり意味が無いが、レンダラーなどの「その素子はどの領域を占めているのか」という情報が必要なコードからよく参照される。
 */

//==========================================================================================================
/**
 * 指定された領域をボディとするボディビヘイバー。
 */
class BodyBehavior extends Behavior {

    //------------------------------------------------------------------------------------------------------
    /**
     * 宿主が存在する領域を宿主の座標系で返す。宿主の座標系で返すので宿主のスケールやポジションの影響は受けない。
     *
     * @return  宿主が存在する領域を表すRect。
     */
    getRect() {

        throw new Error("実装して下さい");
    }

    //------------------------------------------------------------------------------------------------------
    /**
     * ビヘイバーのデフォルト名を定義する。
     */
    get defaultKeyName() {
        return "body";
    }

    //------------------------------------------------------------------------------------------------------
    /**
     * 文字列化が求められたとき、参考情報も加える。デバッグ用。
     */
    toString() {

        return `${super.toString()}  ${this.getRect().explain()}`;
    }
}


//==========================================================================================================
/**
 * 指定された領域をボディとするボディビヘイバー。
 */
class FreeBody extends BodyBehavior {

    //------------------------------------------------------------------------------------------------------
    /**
     * @param   ボディとしたい矩形。あるいはRectコンストラクタへの引数リスト。
     */
    constructor(...args) {
        super();

        this.rect = new Rect(...args);
    }

    //------------------------------------------------------------------------------------------------------
    /**
     * オーバーライド。宿主が存在する領域を宿主の座標系で返す。
     */
    getRect() {

        return this.rect.clone();
    }

    //------------------------------------------------------------------------------------------------------
    /**
     * 領域矩形の絶対的位置を保ったまま、宿主のpositionを指定された位置に動かす。
     *
     * @param...    新しいpositionの、宿主座標系における位置。
     */
    setBasingPoint(...args) {

        var point = new Point(...args);

        // 領域矩形を指定された位置を原点とした位置に動かす。
        this.rect.lt.subInto(point);

        // 宿主のpositionを指定された位置に動かすのだが、宿主座標系における値になっているため、その親の座標系に直してから適用する。
        this.host.position.put( this.host.parentCoord(point) );
    }

    //------------------------------------------------------------------------------------------------------
    /**
     * setBasingPoint() と同じだが、座標ではなく領域矩形の割合位置で指定する。
     *
     * @param...    新しいpositionの、領域矩形における割合位置。例えば左下なら (0.0, 1.0) を指定する。
     */
    setBasingPivot(...args) {

        // 指定された割合位置から座標を取得して、あとは setBasingPoint() へ。
        var point = this.rect.getPoint(...args);

        this.setBasingPoint(point);
    }

    //------------------------------------------------------------------------------------------------------
    /**
     * setBasingPoint() と同じだが、宿主座標系ではなく、親の座標系で指定する。
     *
     * @param...    新しいpositionの、宿主の親座標系における位置。
     */
    setPosition(...args) {

        // 宿主の親座標系における座標を宿主の座標系に直して、あとは setBasingPoint() へ。
        var point = this.host.getCoord( new Point(...args) );

        this.setBasingPoint(point);
    }
}


//==========================================================================================================
/**
 * レンダラが持つ描画素材の大きさをそのまま使って、宿主の座標位置に中央が来るようにボディ位置を決めるビヘイバー。
 */
class NaturalBody extends BodyBehavior {

    //------------------------------------------------------------------------------------------------------
    /**
     * オーバーライド。宿主が存在する領域を宿主の座標系で返す。
     */
    getRect() {

        // まだアタッチされてないなら計算できない。
        if(!this.host)  return Rect.ZERO;

        // レンダラがなかったら計算できない。
        var renderer = this.host.behaviors.get("renderer");
        if(!renderer)  return Rect.ZERO;

        // レンダラのプロパティからサイズを取得して、それを元に宿主のボディを求める。
        return this.laydown(renderer.naturalSize);
    }

    //------------------------------------------------------------------------------------------------------
    /**
     * 引数に指定されたイメージサイズからボディ矩形を計算する。
     *
     * @param   サイズを表す Point。
     * @return  ボディ矩形。
     */
    laydown(size) {

        // 宿主の座標位置に中央が来るようにボディ領域を求める。
        return Rect.byCenter(Point.ZERO, size);
    }
}


//==========================================================================================================
/**
 * NaturalBody と同じだが、ピボットやスケールを指定できるようにしたもの。NaturalBody から派生している。
 */
class RevisionBody extends NaturalBody {

    //------------------------------------------------------------------------------------------------------
    /**
     * @param   ピボットの位置(Point)。宿主の座標をイメージ上のどこに合わせるか。
     *          描画イメージの倍率で指定する。例えば左端なら0.0、中心なら0.5、右端なら1.0。省略時は中心。
     * @param   描画倍率(Point)。描画イメージの倍率で指定する。半分にするなら0.5、倍サイズにするなら2.0。省略時はそのまま。
     * @param   オフセット(Point)。省略時は0。
     */
    constructor(pivot, scale, offset) {
        super();

        this.pivot = new Point( (pivot == undefined) ? 0.5 : pivot );
        this.scale = new Point( (scale == undefined) ? 1.0 : scale );
        this.offset = new Point(offset);
    }

    //------------------------------------------------------------------------------------------------------
    /**
     * オーバーライド。引数に指定されたイメージサイズからボディ矩形を計算する。
     */
    laydown(size) {

        // イメージのサイズにスケールを反映。
        size = size.multi(this.scale);

        // ピボットから左上位置を取得。
        var rect = Rect.byPivot(this.pivot, size);

        // オフセットを適用して出来上がり。
        rect.lt.addInto(this.offset);
        return rect;
    }
}


//==========================================================================================================
/**
 * キャンバスに映る領域をボディとするビヘイバー。
 */
class CanvasBody extends BodyBehavior {

    //------------------------------------------------------------------------------------------------------
    /**
     * オーバーライド。宿主が存在する領域を宿主の座標系で返す。
     */
    getRect() {

        var scene = this.host.getScene();
        var rect = scene.behaviors.get("body").getRect();

        return scene.spinCoord(rect, this.host).normalize();
    }
}
