/**
 * 実行素子にUIインタラクションに関する処理を実装出来るようにするビヘイバー(インタラクションビヘイバー)を収めたクラス。
 */

//==========================================================================================================
/**
 * インタラクションビヘイバー。次のような実装になっている。
 * ・インタラクションを必要とする領域の取得に宿主の "body" ビヘイバーを使う。
 * ・インタラクション時の処理は宿主の "touch", "tap", "drag", "hover" というメソッドに委譲する。
 *
 *      tap(pos)
 *          posはタッチされた座標。タップされたら発行される。ロングタップやドラッグでは発行されない。
 *          touchend(mouseup) 時に発行されるため、スマートデバイスでも Audio.play() などが有効に働く。
 *
 *      drag(move)
 *          moveはドラッグベクトル。ドラッグされたら発行される。
 *
 *      touch(pos)
 *          posはタッチされた座標。タッチ開始時に直ちに発行される。そのため、タップとドラッグの区別などは付けられないし、ロングタップ判定もできない、
 *          ピンチイン・アウト時の一本目の指のタッチにも反応するなどの問題がある。
 *          アクションゲームなどでtapでは反応が遅いと判断される場合に使用する。
 *
 *      hover(enter)
 *          enterはマウスが入ってきた(true)のか出て行った(false)のかを表す。マウスホバーの開始と終了で発行される。
 *          出入のタイミング以外で適宜ホバー中かどうかを知りたい場合は、このビヘイバーの hoverpos プロパティを見ることでも達成出来る。
 *          レイヤーは考慮されない点に注意。まだアルファ実装かな…
 *
 * ※宿主となる実行素子はlayerが設定されている必要がある。
 */
class InteractBehavior extends Behavior {

    //------------------------------------------------------------------------------------------------------
    constructor() {
        super();

        // マウスが宿主の領域に入っている間、マウスの位置が格納される。領域に入っていない間は null。
        this.hoverpos = null;
    }

    //------------------------------------------------------------------------------------------------------
    /**
     * 引数で指定された座標で、どの系統のイベントに反応するのかを返す。
     *
     * @param   座標
     * @return  予定インタラクション種別。"tap", "drag" のいずれかを列挙した配列。
     *          指定された座標ではいずれも処理しないならカラの配列を返す。
     */
    sense(point) {

        // 指定された座標でインタラクションするなら、どの系統のイベントに反応するのかを調べて返す。
        // インタラクションしないならカラの配列。
        return this.isSensitive(point) ? this.getWatchingEvents() : [];
    }

    //------------------------------------------------------------------------------------------------------
    /**
     * 引数で指定された座標でのUIインタラクションを処理するかどうかを返す。
     *
     * @param   座標
     * @return  処理するならtrue、しないならfalse。
     */
    isSensitive(point) {

        // 基底の実装としては、宿主のlayerが正しく設定されており...
        if(this.host.layer == undefined)  return false;

        // 宿主の "body" ビヘイバーの...
        var body = this.host.behaviors.get("body");
        if(!body)  return false;

        // 領域内に指定された座標があるかどうかで判断する。
        return body.getRect().inside(point);
    }

    //------------------------------------------------------------------------------------------------------
    /**
     * どの系統のイベントに反応するのかを返す。
     *
     * @return  予定インタラクション種別。"tap", "drag" のいずれかを列挙した配列。いずれも処理しないならカラの配列を返す。
     */
    getWatchingEvents() {

        // 基底の実装としては、宿主に tap, drag, touch の各メソッドがあるかどうかで判断する。

        var result = [];

        if(typeof(this.host.tap) == "function"  ||  typeof(this.host.touch) == "function")
            result.push("tap");

        if(typeof(this.host.drag) == "function")
            result.push("drag");

        return result;
    }

    //------------------------------------------------------------------------------------------------------
    /**
     * マウスのホバー状態を管理する。
     *
     * @param   マウスカーソルの位置。
     */
    watchHovering(pointer) {

        var body = this.host.behaviors.get("body");

        // ホバー状態かどうかを取得。
        var hovering = !!body  &&  body.getRect().inside(pointer);

        // ホバー状態が変化したなら...
        if(!!this.hoverpos != hovering) {

            // "hover" インタラクションを処理する。
            this.interact("hover", hovering);

            // ホバーが終わったなら hoverpos をクリアする。
            if(!hovering)  this.hoverpos = null;
        }

        // ホバー中はマウスの位置を追跡する。
        if(hovering)  this.hoverpos = pointer.clone();
    }

    //------------------------------------------------------------------------------------------------------
    /**
     * UIインタラクションに対する反応を行う。
     *
     * @param   インタラクション種別。"tap", "drag", "touch", "hover" のいずれか。
     * @param   インタラクションの引数。種別によって値は異なる。
     *              tap, touch  タッチ地点
     *              drag        ドラッグ距離
     *              hover       ホバーインしたなら true、ホバーアウトしたなら false
     */
    interact(type, arg1) {

        // 宿主に該当メソッドがあるならコールする。
        if(typeof(this.host[type]) == "function")
            this.host[type](arg1);
    }

    //------------------------------------------------------------------------------------------------------
    /**
     * ビヘイバーのデフォルト名を定義する。
     */
    get defaultKeyName() {
        return "interactor";
    }
}


//==========================================================================================================
/**
 * InteractBehavior と同じだが、宿主のボディ矩形のみで反応するのではなく全ての座標で反応する点が異なる。
 */
class WholeInteractor extends InteractBehavior {

    //------------------------------------------------------------------------------------------------------
    /**
     * 全ての座標で反応するようにする。
     */
    isSensitive(point) {

        return true;
    }
}


//==========================================================================================================
/**
 * InteractBehavior の挙動で、ドラッグを宿主のpositionの移動で固定したもの。
 */
class DraggableInteractor extends InteractBehavior {

    //------------------------------------------------------------------------------------------------------
    /**
     * オーバーライド。宿主に drag() メソッドがあるかどうかに関わらず、dragに応答するようにする。
     */
    getWatchingEvents() {

        var result = super.getWatchingEvents();

        if( !result.includes("drag") )
            result.push("drag");

        return result;
    }

    //------------------------------------------------------------------------------------------------------
    /**
     * オーバーライド。
     */
    interact(type, arg1) {

        // dragで宿主のposition移動を行う。
        if(type == "drag")  this.host.position.addInto(arg1);

        super.interact(type, arg1);
    }

}
