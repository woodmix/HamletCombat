
/**
 * Executant の behaviors, childs を提供するクラス(房)。
 */
class LeavesBunch {

    //------------------------------------------------------------------------------------------------------
    /**
     * @param   この房の持ち主となる実行素子。
     */
    constructor(trunk) {

        // この房にセットされている要素のコレクション。
        this.leaves = {};

        // 予約操作の配列。
        this.buds = [];

        // この房の持ち主となっている実行素子。
        this.trunk = trunk;
    }

    //------------------------------------------------------------------------------------------------------
    /**
     * 引数で指定された名前の要素を返す。
     *
     * @return  指定された名前の要素。ない場合は undefined。
     */
    get(name) {

        return this.leaves[name];
    }

    //------------------------------------------------------------------------------------------------------
    /**
     * get()と同じだが、要素がない場合は指定されたコンストラクタで作成する。
     *
     * @param   取得したい要素の名前。
     * @param   ない場合に作成・追加されるクラス。
     * @return  指定された名前の要素。ない場合は undefined。
     */
    need(name, generator) {

        var result = this.get(name);

        if(!result) {
            result = new generator();
            this.sprout({leaf:result, name:name});
        }

        return result;
    }

    //------------------------------------------------------------------------------------------------------
    /**
     * 引数で指定された名前の要素を予約操作も含めて探す。
     *
     * @param   要素の名前。
     * @return  指定された名前の要素。ない場合は undefined。
     */
    search(name) {

        // まずは既に存在する要素から探す。
        var leaf = this.get(name);

        // 見付からないなら予約操作も探す。
        if(!leaf) {
            var bud = this.buds.find( bud => bud.name == name );
            if(bud)  leaf = bud.leaf;
        }

        return leaf;
    }

    //------------------------------------------------------------------------------------------------------
    /**
     * 引数で指定された要素を指定された名前でセット予約する。実際の追加は次に germinate() を呼び出したとき(素子のアップデートフェーズで行われる)に
     * まとめて行われる。
     * こうしているのは、たとえばアップデードフェーズの途中に追加されてそのまま初期化されずにドローフェーズで呼ばれるなど、初期化されていないままに
     * フレームサイクルの途中から参加してしまうことになる事態を防ぐため。
     *
     * @param   新しく配置される要素。
     * @param   要素の名前。省略した場合は自動的に決められる。
     */
    set(into, name) {

        // よくある…
        if(!into)  throw new Error("引数が変です: " + into);

        this.buds.push({name:name, leaf:into});
    }

    //------------------------------------------------------------------------------------------------------
    /**
     * set() と同じだが、指定された文字列で始まる名前を自動的に決める点が異なる。
     *
     * @param   追加する要素。
     * @param   要素の名前の先頭部分。これより後に自動的に決められた文字列が追加されて名前となる。
     */
    setWith(into, prefix) {

        if(!into)  throw new Error("引数が変です: " + into);

        this.buds.push({prefix:prefix, leaf:into});
    }

    //------------------------------------------------------------------------------------------------------
    /**
     * set() で予約されているコマンドを実行する。
     */
    germinate() {

        this.buds.forEach( bud => this.sprout(bud) );

        // キューをクリアする。
        this.buds.length = 0;
    }

    //------------------------------------------------------------------------------------------------------
    /**
     * 引数で指定された操作をただちに実行する。
     *
     * @param   操作の内容を表す連想配列。以下のキーを持つ。
     *              name    追加・変更・削除する要素の名前
     *              leaf    追加・変更時の新しい要素。nullとした場合は該当要素が削除される。
     *              prefix  nameを自動的に決める場合の接頭辞。
     */
    sprout(bud) {

        // 名前が省略されている場合は空きを探して自動的に決定する。
        if(bud.name == null)
            bud.name = this.decideName(bud);

        // まずは既存の削除。
        var outof = this.leaves[bud.name];
        if(outof)  delete this.leaves[bud.name];

        // 指定された要素の追加。
        if(bud.leaf)  this.leaves[bud.name] = bud.leaf;

        // 房が変更された場合のコールバックをコール。
        if(outof != bud.leaf)  this.onoperate(bud.name, outof, bud.leaf);
    }

    /**
     * 名前が省略されている場合の決定処理を行う。
     *
     * @param   操作の内容を表す連想配列。sprout() と同様。
     */
    decideName(bud) {
    }

    /**
     * 房が変更された場合の処理を行う。
     *
     * @param   操作されたインデックス。
     * @param   削除された場合にその要素。
     * @param   追加された場合にその要素。
     */
    onoperate(name, outof, into) {
    }

    //------------------------------------------------------------------------------------------------------
    /**
     * 引数で指定された要素を削除する。追加とは違って直ちに実行される。
     *
     * @param   削除したい要素、あるいはその名前。
     */
    cut(name) {

        // インスタンスで指定されている場合は...
        if(typeof(name) != "string") {

            // その名前を探す。見付からない場合は何もしない。
            name = this.nameOf(name);
            if(name == undefined)  return;
        }

        this.sprout({name:name, leaf:null});
    }

    //------------------------------------------------------------------------------------------------------
    /**
     * 引数で指定された要素の名前を取得する。
     *
     * @param   名前を取得したい要素。
     * @return  要素の名前。見付からない場合は null。
     */
    nameOf(leaf) {

        return this.leaves.index(leaf);
    }
}


//==========================================================================================================
/**
 * 実行素子の behaviors プロパティとなる房を表すクラス。
 */
class BehaviorLeaves extends LeavesBunch {

    //------------------------------------------------------------------------------------------------------
    /**
     * オーバーライド。名前が省略されている場合の決定処理を行う。
     */
    decideName(bud) {

        return (bud.prefix || "") + bud.leaf.defaultKeyName;
    }

    //------------------------------------------------------------------------------------------------------
    /**
     * オーバーライド。房が変更された場合の処理を行う。
     */
    onoperate(name, outof, into) {

        // 削除・追加された要素の attached() の呼び出しを行う。
        if(outof)  outof.attached(null);
        if(into)  into.attached(this.trunk);
    }
}


//==========================================================================================================
/**
 * 実行素子の childs プロパティとなる房を表すクラス。
 */
class ChildLeaves extends LeavesBunch {

    //------------------------------------------------------------------------------------------------------
    /**
     * オーバーライド。名前が省略されている場合の決定処理を行う。
     */
    decideName(bud) {

        // 接頭辞を取得。
        var prefix = bud.prefix || "";

        // 数値を使って空きを探す。
        for(name = 1 ; this.leaves[prefix + name] ; name++);

        return prefix + name;
    }

    //------------------------------------------------------------------------------------------------------
    /**
     * オーバーライド。房が変更された場合の処理を行う。
     */
    onoperate(name, outof, into) {

        // 削除要素がある場合は、その要素が削除されたことを分かるようにする。
        if(outof)  outof.parent = null;

        // 追加要素がある場合は...
        if(into) {

            // その要素のparentプロパティを設定。
            into.parent = this.trunk;

            // その要素の次の update() の前に activate() がコールされるようにする。
            delete into.activate;
        }

        // 素子の階層変更処理を呼び出す。
        this.trunk.layerChanged();
    }
}
