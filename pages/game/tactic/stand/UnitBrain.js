
/**
 * ユニットの行動決定処理を行うオブジェクト(ブレイン)の基底。
 * ビヘイバーとしても振る舞い、ユニットタスクの管理も行う。
 */
class UnitBrain extends Behavior {

    //------------------------------------------------------------------------------------------------------
    constructor() {
        super();

        // タスクキューと実行中のタスク。
        this.queue = [];
        this.runningTask = null;
    }

    //------------------------------------------------------------------------------------------------------
    /**
     * 次のアクションを決定して実行する。
     */
    perform() {

        throw new Error("実装して下さい");
    }

    //------------------------------------------------------------------------------------------------------
    /**
     * アクション決定中かどうかを表す。
     */
    get deciding() {

        // 基底としては、思考は一瞬で決定されるものとする。
        return false;
    }

    //------------------------------------------------------------------------------------------------------
    /**
     * ユーティリティメソッド。現在位置から移動可能なブロックを列挙する。
     *
     * @return  移動可能なブロックの配列
     */
    listTravels() {

        // 移動可能なブロックを取得。敵ユニットが居るブロックは列挙されない。
        var travels = this.host.seatblock.getTravels(this.host.specs.legs, this.host);

        // 他のユニットが居るブロックには移動出来ないので除外しておく。ただ、自分がいるブロックは残しておく。
        return travels.filter(block => !block.logicalUnit || block.logicalUnit == this.host);
    }

    //------------------------------------------------------------------------------------------------------
    /**
     * 引数に指定されたブロックを基点として、攻撃可能範囲にあるブロックを列挙する。
     *
     * @param   基点となるブロック
     * @return  攻撃可能範囲にあるブロックの配列
     */
    listAimables(launchpad) {

        var range = this.host.specs["range"];
        return launchpad.getTravels(range);
    }


    // タスクの管理
    //======================================================================================================

    //------------------------------------------------------------------------------------------------------
    /**
     * 引数に指定されたタスクをキューに追加する。
     *
     * @param   タスクを表す構造体。
     */
    pushTask(task) {

        var task = UnitTask.createTask(this.host, task);
        this.queue.push(task);
    }

    //------------------------------------------------------------------------------------------------------
    /**
     * 実行中タスクがあるかどうかを表す。
     */
    get undertaking() {

        return this.runningTask  ||  this.queue.length >= 1;
    }

    //------------------------------------------------------------------------------------------------------
    /**
     * オーバーライド。フレームごとのアップデートフェーズで呼ばれる。
     */
    behave(scene) {

        // 実行中のタスクがある場合は終了をチェックする。
        if(this.runningTask)
            if( !this.runningTask.isRunning() )  this.runningTask = null;

        // 実行中のタスクがない場合は...
        if( !this.runningTask ) {

            // キューからタスクを取り出して実行する。
            var task = this.queue.shift();
            if(task) {
                task.issue(scene.time);
                this.runningTask = task;
            }
        }
    }

    //------------------------------------------------------------------------------------------------------
    /**
     * 文字列化が求められたとき、参考情報も加える。デバッグ用。
     */
    toString() {

        var queue = this.queue.map(command => command.constructor.name);

        return `${super.toString()}  running:${this.runningTask}  queue:[${this.queue}]`;
    }
}
