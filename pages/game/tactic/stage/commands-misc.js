/**
 * その他ステージコマンドを納める。
 * コマンド内の各キーについては art/stages.txt のコマンドに関する説明を参照。
 */

//==========================================================================================================
/**
 * type:start のコマンドを取り扱うクラス。
 */
class StartCommand extends StageCommand {

    //------------------------------------------------------------------------------------------------------
    /**
     * オーバーライド。コマンドが現在実行中かどうかを返す。
     */
    isRunning(stage) {

        // シーンが開始されないうちは処理しない。シーン切り替え中のタイミングが該当する。
        return stage.getScene().time == 0;
    }
}


//==========================================================================================================
/**
 * type:call のコマンドを取り扱うクラス。
 */
class CallCommand extends StageCommand {

    //------------------------------------------------------------------------------------------------------
    /**
     * オーバーライド。コマンドを実行する。
     */
    run(stage) {

        // 指定されたメソッドを呼び出す。
        this.target[this.method]( ...(this.args || []) );
    }
}


//==========================================================================================================
/**
 * type:popup のコマンドを取り扱うクラス。
 */
class PopupCommand extends StageCommand {

    //------------------------------------------------------------------------------------------------------
    /**
     * オーバーライド。コマンドを実行する。
     */
    run(stage) {

        // ポップアップ表示素子を作成して...
        this.popup = new PopupExecutant(this.graph);

        // シーン素子の直下に追加。
        this.supervisor.host.getScene().childs.set(this.popup, "popup");
    }

    //------------------------------------------------------------------------------------------------------
    /**
     * オーバーライド。コマンドが現在実行中かどうかを返す。
     */
    isRunning(stage) {

        // ポップアップ表示素子が階層ツリーに存在中は実行中とする。
        return !!this.popup.parent;
    }
}


//==========================================================================================================
/**
 * type:goal のコマンドを取り扱うクラス。
 */
class GoalCommand extends StageCommand {

    //------------------------------------------------------------------------------------------------------
    /**
     * オーバーライド。コマンドを実行する。
     */
    run(stage) {

        stage.getScene().processGoal();
    }

    //------------------------------------------------------------------------------------------------------
    /**
     * オーバーライド。コマンドが現在実行中かどうかを返す。
     */
    isRunning(stage) {

        // 一度始まると完了することはない。
        return true;
    }

    //------------------------------------------------------------------------------------------------------
    /**
     * オーバーライド。このコマンドが指定された先行コマンドと並列実行出来るかどうかを返す。
     */
    canParallelize(command, now) {

        // 先行しているのがターンコマンドなら割り込んで(?)実行する。こうしないと、クリア条件を満たした直後にマニュアル操作ユニットに順番が回ったとき、
        // 操作を完了してコマンドを終了させないとクリア演出に移行しないという現象になる。割と緊急回避コード。
        if(command instanceof TurnCommand)  return true;

        return super.canParallelize(command, now);
    }
}


//==========================================================================================================
/**
 * type:miss のコマンドを取り扱うクラス。
 */
class MissCommand extends StageCommand {

    //------------------------------------------------------------------------------------------------------
    /**
     * オーバーライド。コマンドを実行する。
     */
    run(stage) {

        stage.getScene().processOver();
    }

    //------------------------------------------------------------------------------------------------------
    /**
     * オーバーライド。コマンドが現在実行中かどうかを返す。
     */
    isRunning(stage) {

        // 一度始まると完了することはない。
        return true;
    }
}


//==========================================================================================================
/**
 * type:batch のコマンドを取り扱うクラス。
 */
class BatchCommand extends StageCommand {

    //------------------------------------------------------------------------------------------------------
    /**
     * コンストラクタで追加の処理を行う。
     */
    constructor(supervisor, props) {
        super(supervisor, props);

        this.commands = this.commands.map( command => StageCommand.createCommand(supervisor, command) );
    }

    //------------------------------------------------------------------------------------------------------
    /**
     * オーバーライド。コマンドを実行する。
     */
    run(stage) {

        for(var command of this.commands)
            command.issue(stage, this.issuedTime);
    }

    //------------------------------------------------------------------------------------------------------
    /**
     * オーバーライド。コマンドが現在実行中かどうかを返す。
     */
    isRunning(stage) {

        return this.commands.some( command => command.isRunning(stage) );
    }

    //------------------------------------------------------------------------------------------------------
    /**
     * オーバーライド。このコマンドが指定されたコマンドと並列実行出来るかどうかを返す。
     */
    canParallelize(command, now) {

        // まずは自身がチェック。
        if( !super.canParallelize(command, now) )  return false;

        // さらにエントリされているコマンドがすべて並列可能と報告するなら、並列実行出来る。
        return this.commands.every( entry => entry.canParallelize(command, now) );
    }
}
